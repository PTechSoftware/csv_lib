use std::sync::{Arc, Mutex};
use crate::models::csv_config::CsvConfig;
use crate::models::in_row_iter::InRowIter;
use crate::models::row::Row;
use crate::models::worker_status::WorkerResult;
use crate::models::workers::Worker;


/// ## MasterParallel struct
/// - Handler the distribution of the workload.
pub struct MasterParallel<'mmap, F, T>
where
    F: FnMut(&mut Row<'mmap>, &CsvConfig, &mut Arc<Mutex<T>>) + Send + Clone + 'mmap,
    T: Send + 'mmap,
{
    execution : F,
    target : &'mmap mut Arc<Mutex<T>>,
    file: &'mmap [u8],
    cfg: &'mmap CsvConfig

}


impl<'mmap, F, T> MasterParallel<'mmap, F, T>
where
    F: FnMut(&mut Row<'mmap>, &CsvConfig, &mut Arc<Mutex<T>>) + Send+ Clone + 'mmap,
    T: Send + 'mmap,
{

    /// ## Constructor
    /// Creates a new master instance.
    ///
    /// ## Arguments:
    /// - `file`: A reference of the slice generated by Mmap
    /// - `execution` : A closure with the code to inject in each row process
    /// - `target` : A generic struct that you can use to acumulate data(be sure is inside an Arc/Mutex)
    pub fn new(
        file: &'mmap [u8],
        cfg: &'mmap CsvConfig,
        execution: F,
        target: &'mmap mut Arc<Mutex<T>>,

    ) -> Self {
        Self {
            execution,
            target,
            file,
            cfg
        }
    }
    /// Get available number of cores
    fn get_cores() -> usize {
        std::thread::available_parallelism()
            .map(|n| n.get())
            .unwrap_or(4)
    }

    /// ## Runner One Thread
    ///
    /// - Processes assigned lines with the provided closure.
    /// - Is the Async version of the library, processing is sequential, and only uses one core.
    pub async fn run_parallel_one_thread<'a>(&'a mut self) -> WorkerResult
    where
        'a: 'mmap
    {
        let closure: F = self.execution.clone();
        let mut w = Worker::new(
            self.file,
            self.cfg,
            0,
            self.file.len(),
            closure,
            self.target.clone(),
        );
        w.runner_row().await
    }


    /// ## Parallel by line [[MultiThread]]
    /// - Splits the slice, and allow to process part of the file in each worker.
    /// - Never copy the file, each worker take a chunk of the slice to process.Each slice is a complete row.
    /// - Try to equiparate the load between threads
    pub fn run_parallel_by_lines(&mut self) -> WorkerResult
    where
        T: Send,
        F: FnMut(&mut Row<'mmap>, &CsvConfig, &mut T) + Send + Clone,
    {
        use crossbeam::thread;
        use std::cmp::min;

        let num_threads = Self::get_cores();
        let line_break = self.cfg.line_break;
        let string_scape = self.cfg.string_separator;
        let file = self.file;
        let cfg = self.cfg;
        let total_len = file.len();

        if total_len == 0 {
            return WorkerResult::Ok;
        }

        // 1. Calcular posiciones de corte por nÃºcleos
        let average = total_len / num_threads;
        let mut positions = vec![0; num_threads + 1];
        positions[0] = 0;

        let mut iterator = InRowIter::new(file, line_break, string_scape);
        iterator.set_cursor(average);

        for i in 1..=num_threads {
            if let Some(_) = iterator.next() {
                let current_cursor = iterator.get_cursor();
                positions[i] = min(current_cursor, total_len);
                iterator.set_cursor(positions[i] + average);
            } else {
                positions[i] = total_len;
            }
        }

        // 2. Ejecutar en paralelo cada chunk
        let result = thread::scope(|s| {
            for i in 0..num_threads {
                let start = positions[i];
                let end = positions[i + 1];
                if start >= end {
                    continue;
                }

                let slice = &file[start..end];
                let closure = self.execution.clone();
                let cfg = cfg;
                let target = Arc::clone(&self.target);

                s.spawn(move |_| {
                    let mut worker = Worker::new(slice, cfg, 0, slice.len(), closure, target);
                    let _ = futures::executor::block_on(worker.runner_row());
                });
            }
        }).map_err(|e| WorkerResult::Err(format!("Thread error: {:?}", e)));

        match result {
            Ok(_) => WorkerResult::Ok,
            Err(e) => e,
        }
    }
}